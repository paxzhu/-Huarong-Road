{"ast":null,"code":"function createDest(m, n) {\n  let dest = Array.from({\n    length: m\n  }, (_, i) => Array.from({\n    length: n\n  }, (_, j) => i * n + j + 1));\n  dest[m - 1][n - 1] = 0;\n  return dest;\n}\nfunction parity(puzzle) {\n  const m = puzzle.length,\n    n = puzzle[0].length;\n  let flatten = Array(m * n).fill(null).map((_, i) => puzzle[Math.floor(i / n)][i % n]);\n  let cnt = 0,\n    pair;\n  for (let i = 0; i < m * n; i++) {\n    for (let j = i + 1; j < m * n; j++) {\n      if (flatten[i] != 0 && flatten[j] != 0 && flatten[i] > flatten[j]) {\n        cnt += 1;\n        pair = [i, j];\n      }\n    }\n  }\n  if (cnt % 2 == 1) {\n    let i = pair[0],\n      j = pair[1];\n    let tmp = puzzle[Math.floor(i / n)][i % n];\n    puzzle[Math.floor(i / n)][i % n] = puzzle[Math.floor(j / n)][j % n];\n    puzzle[Math.floor(j / n)][j % n] = tmp;\n  }\n}\nfunction shuffle(m, n) {\n  let shuffled = Array.from({\n    length: m * n\n  }, (_, i) => i);\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  let puzzle = Array.from({\n    length: m\n  }, (_, i) => shuffled.slice(i * n, (i + 1) * n));\n  parity(puzzle);\n  return puzzle;\n}\nfunction heuristic(dest) {\n  const m = dest.length;\n  const n = dest[0].length;\n  const locs = Array.from({\n    length: m * n\n  }, () => [0, 0]);\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      locs[dest[i][j]] = [i, j];\n    }\n  }\n  function manhattans(puzzle) {\n    let distance = 0;\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        const [x, y] = locs[puzzle[i][j]];\n        const manhattan = Math.abs(x - i) + Math.abs(y - j);\n        distance += manhattan;\n      }\n    }\n    return distance;\n  }\n  return manhattans;\n}\nfunction locateZero(puzzle) {\n  for (let i = 0; i < puzzle.length; i++) {\n    for (let j = 0; j < puzzle[0].length; j++) {\n      if (puzzle[i][j] === 0) {\n        return [i, j];\n      }\n    }\n  }\n}\nfunction neighbors(status) {\n  const puzzle = status.map(row => row.slice());\n  const [i, j] = locateZero(puzzle);\n  const neis = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n  const validNeighbors = [];\n  for (const [di, dj] of neis) {\n    const x = i + di;\n    const y = j + dj;\n    if (x >= 0 && x < puzzle.length && y >= 0 && y < puzzle[0].length) {\n      [puzzle[i][j], puzzle[x][y]] = [puzzle[x][y], puzzle[i][j]];\n      validNeighbors.push(puzzle.map(row => row.slice()));\n      [puzzle[i][j], puzzle[x][y]] = [puzzle[x][y], puzzle[i][j]];\n    }\n  }\n  return validNeighbors;\n}\nfunction traceToDest(visited, dest) {\n  const path = [dest];\n  while (visited[dest]) {\n    const pre = visited[dest];\n    path.push(pre);\n    dest = pre;\n  }\n  return path.reverse();\n}\nexport function astar(puzzle, dest) {\n  const manhattans = heuristic(dest);\n  const start = JSON.stringify(puzzle);\n  const target = JSON.stringify(dest);\n  const heap = [[manhattans(start), 0, startTuple]];\n  const visited = {};\n  visited[JSON.stringify(start)] = null;\n  while (heap.length > 0) {\n    const [evaluate, depth, status] = heap.shift();\n    if (JSON.stringify(status) === JSON.stringify(target)) {\n      break;\n    }\n    for (const nei of neighbors(status)) {\n      const strNei = JSON.stringify(nei);\n      if (!visited[strNei]) {\n        visited[strNei] = status;\n        heap.push([depth + 1 + manhattans(nei), depth + 1, nei]);\n      }\n    }\n    heap.sort((a, b) => a[0] - b[0]);\n  }\n  if (!visited[JSON.stringify(target)]) {\n    console.log(\"invalid puzzle\");\n    return null;\n  }\n  const path = traceToDest(visited, JSON.stringify(target));\n  return path.map(step => step.map(row => row.slice()));\n}","map":{"version":3,"names":["createDest","m","n","dest","Array","from","length","_","i","j","parity","puzzle","flatten","fill","map","Math","floor","cnt","pair","tmp","shuffle","shuffled","random","slice","heuristic","locs","manhattans","distance","x","y","manhattan","abs","locateZero","neighbors","status","row","neis","validNeighbors","di","dj","push","traceToDest","visited","path","pre","reverse","astar","start","JSON","stringify","target","heap","startTuple","evaluate","depth","shift","nei","strNei","sort","a","b","console","log","step"],"sources":["/home/zpc/Code/MyProjects/Huayongroad/src/AStar.js"],"sourcesContent":["function createDest(m, n) {\n    let dest = Array.from({ length: m }, (_, i) => Array.from({ length: n }, (_, j) => i * n + j + 1));\n    dest[m - 1][n - 1] = 0;\n    return dest;\n}\nfunction parity(puzzle) {\n    const m = puzzle.length, n = puzzle[0].length;\n    let flatten = Array(m*n).fill(null).map((_, i) => puzzle[Math.floor(i/n)][i%n]);\n    let cnt = 0, pair;\n  \n    for(let i = 0; i < m*n; i++) {\n      for(let j = i+1; j < m*n; j++) {\n        if(flatten[i] != 0 && flatten[j] != 0 && flatten[i] > flatten[j]) {\n          cnt += 1;\n          pair = [i, j];\n        }\n      }\n    }\n  \n    if(cnt % 2 == 1) {\n      let i = pair[0], j = pair[1];\n      let tmp = puzzle[Math.floor(i/n)][i%n];\n      puzzle[Math.floor(i/n)][i%n] = puzzle[Math.floor(j/n)][j%n];\n      puzzle[Math.floor(j/n)][j%n] = tmp;\n    }\n  }\n  \nfunction shuffle(m, n) {\n    let shuffled = Array.from({ length: m * n }, (_, i) => i);\n    for (let i = shuffled.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    let puzzle = Array.from({ length: m }, (_, i) => shuffled.slice(i * n, (i + 1) * n));\n    parity(puzzle);\n    return puzzle;\n}\n\nfunction heuristic(dest) {\n    const m = dest.length;\n    const n = dest[0].length;\n    const locs = Array.from({ length: m * n }, () => [0, 0]);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            locs[dest[i][j]] = [i, j];\n        }\n    }\n    function manhattans(puzzle) {\n        let distance = 0;\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                const [x, y] = locs[puzzle[i][j]];\n                const manhattan = Math.abs(x - i) + Math.abs(y - j);\n                distance += manhattan;\n            }\n        }\n        return distance;\n    }\n    return manhattans;\n}\n\nfunction locateZero(puzzle) {\n    for (let i = 0; i < puzzle.length; i++) {\n        for (let j = 0; j < puzzle[0].length; j++) {\n            if (puzzle[i][j] === 0) {\n                return [i, j];\n            }\n        }\n    }\n}\n\nfunction neighbors(status) {\n    const puzzle = status.map(row => row.slice());\n    const [i, j] = locateZero(puzzle);\n    const neis = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    const validNeighbors = [];\n    for (const [di, dj] of neis) {\n        const x = i + di;\n        const y = j + dj;\n        if (x >= 0 && x < puzzle.length && y >= 0 && y < puzzle[0].length) {\n            [puzzle[i][j], puzzle[x][y]] = [puzzle[x][y], puzzle[i][j]];\n            validNeighbors.push(puzzle.map(row => row.slice()));\n            [puzzle[i][j], puzzle[x][y]] = [puzzle[x][y], puzzle[i][j]];\n        }\n    }\n    return validNeighbors;\n}\n\nfunction traceToDest(visited, dest) {\n    const path = [dest];\n    while (visited[dest]) {\n        const pre = visited[dest];\n        path.push(pre);\n        dest = pre;\n    }\n    return path.reverse();\n}\n\nexport function astar(puzzle, dest) {\n    const manhattans = heuristic(dest);\n    const start = JSON.stringify(puzzle);\n    const target = JSON.stringify(dest);\n    const heap = [[manhattans(start), 0, startTuple]];\n    const visited = {};\n    visited[JSON.stringify(start)] = null;\n\n    while (heap.length > 0) {\n        const [evaluate, depth, status] = heap.shift();\n        if (JSON.stringify(status) === JSON.stringify(target)) {\n            break;\n        }\n        for (const nei of neighbors(status)) {\n            const strNei = JSON.stringify(nei);\n            if (!visited[strNei]) {\n                visited[strNei] = status;\n                heap.push([depth + 1 + manhattans(nei), depth + 1, nei]);\n            }\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n\n    if (!visited[JSON.stringify(target)]) {\n        console.log(\"invalid puzzle\");\n        return null;\n    }\n\n    const path = traceToDest(visited, JSON.stringify(target));\n    return path.map(step => step.map(row => row.slice()));\n}\n"],"mappings":"AAAA,SAASA,UAAUA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACtB,IAAIC,IAAI,GAAGC,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEL;EAAE,CAAC,EAAE,CAACM,CAAC,EAAEC,CAAC,KAAKJ,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEJ;EAAE,CAAC,EAAE,CAACK,CAAC,EAAEE,CAAC,KAAKD,CAAC,GAAGN,CAAC,GAAGO,CAAC,GAAG,CAAC,CAAC,CAAC;EAClGN,IAAI,CAACF,CAAC,GAAG,CAAC,CAAC,CAACC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;EACtB,OAAOC,IAAI;AACf;AACA,SAASO,MAAMA,CAACC,MAAM,EAAE;EACpB,MAAMV,CAAC,GAAGU,MAAM,CAACL,MAAM;IAAEJ,CAAC,GAAGS,MAAM,CAAC,CAAC,CAAC,CAACL,MAAM;EAC7C,IAAIM,OAAO,GAAGR,KAAK,CAACH,CAAC,GAACC,CAAC,CAAC,CAACW,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,CAACP,CAAC,EAAEC,CAAC,KAAKG,MAAM,CAACI,IAAI,CAACC,KAAK,CAACR,CAAC,GAACN,CAAC,CAAC,CAAC,CAACM,CAAC,GAACN,CAAC,CAAC,CAAC;EAC/E,IAAIe,GAAG,GAAG,CAAC;IAAEC,IAAI;EAEjB,KAAI,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,GAACC,CAAC,EAAEM,CAAC,EAAE,EAAE;IAC3B,KAAI,IAAIC,CAAC,GAAGD,CAAC,GAAC,CAAC,EAAEC,CAAC,GAAGR,CAAC,GAACC,CAAC,EAAEO,CAAC,EAAE,EAAE;MAC7B,IAAGG,OAAO,CAACJ,CAAC,CAAC,IAAI,CAAC,IAAII,OAAO,CAACH,CAAC,CAAC,IAAI,CAAC,IAAIG,OAAO,CAACJ,CAAC,CAAC,GAAGI,OAAO,CAACH,CAAC,CAAC,EAAE;QAChEQ,GAAG,IAAI,CAAC;QACRC,IAAI,GAAG,CAACV,CAAC,EAAEC,CAAC,CAAC;MACf;IACF;EACF;EAEA,IAAGQ,GAAG,GAAG,CAAC,IAAI,CAAC,EAAE;IACf,IAAIT,CAAC,GAAGU,IAAI,CAAC,CAAC,CAAC;MAAET,CAAC,GAAGS,IAAI,CAAC,CAAC,CAAC;IAC5B,IAAIC,GAAG,GAAGR,MAAM,CAACI,IAAI,CAACC,KAAK,CAACR,CAAC,GAACN,CAAC,CAAC,CAAC,CAACM,CAAC,GAACN,CAAC,CAAC;IACtCS,MAAM,CAACI,IAAI,CAACC,KAAK,CAACR,CAAC,GAACN,CAAC,CAAC,CAAC,CAACM,CAAC,GAACN,CAAC,CAAC,GAAGS,MAAM,CAACI,IAAI,CAACC,KAAK,CAACP,CAAC,GAACP,CAAC,CAAC,CAAC,CAACO,CAAC,GAACP,CAAC,CAAC;IAC3DS,MAAM,CAACI,IAAI,CAACC,KAAK,CAACP,CAAC,GAACP,CAAC,CAAC,CAAC,CAACO,CAAC,GAACP,CAAC,CAAC,GAAGiB,GAAG;EACpC;AACF;AAEF,SAASC,OAAOA,CAACnB,CAAC,EAAEC,CAAC,EAAE;EACnB,IAAImB,QAAQ,GAAGjB,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEL,CAAC,GAAGC;EAAE,CAAC,EAAE,CAACK,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAAC;EACzD,KAAK,IAAIA,CAAC,GAAGa,QAAQ,CAACf,MAAM,GAAG,CAAC,EAAEE,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1C,MAAMC,CAAC,GAAGM,IAAI,CAACC,KAAK,CAACD,IAAI,CAACO,MAAM,CAAC,CAAC,IAAId,CAAC,GAAG,CAAC,CAAC,CAAC;IAC7C,CAACa,QAAQ,CAACb,CAAC,CAAC,EAAEa,QAAQ,CAACZ,CAAC,CAAC,CAAC,GAAG,CAACY,QAAQ,CAACZ,CAAC,CAAC,EAAEY,QAAQ,CAACb,CAAC,CAAC,CAAC;EAC3D;EACA,IAAIG,MAAM,GAAGP,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEL;EAAE,CAAC,EAAE,CAACM,CAAC,EAAEC,CAAC,KAAKa,QAAQ,CAACE,KAAK,CAACf,CAAC,GAAGN,CAAC,EAAE,CAACM,CAAC,GAAG,CAAC,IAAIN,CAAC,CAAC,CAAC;EACpFQ,MAAM,CAACC,MAAM,CAAC;EACd,OAAOA,MAAM;AACjB;AAEA,SAASa,SAASA,CAACrB,IAAI,EAAE;EACrB,MAAMF,CAAC,GAAGE,IAAI,CAACG,MAAM;EACrB,MAAMJ,CAAC,GAAGC,IAAI,CAAC,CAAC,CAAC,CAACG,MAAM;EACxB,MAAMmB,IAAI,GAAGrB,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAEL,CAAC,GAAGC;EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACxD,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,EAAEO,CAAC,EAAE,EAAE;IACxB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,EAAEO,CAAC,EAAE,EAAE;MACxBgB,IAAI,CAACtB,IAAI,CAACK,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC,GAAG,CAACD,CAAC,EAAEC,CAAC,CAAC;IAC7B;EACJ;EACA,SAASiB,UAAUA,CAACf,MAAM,EAAE;IACxB,IAAIgB,QAAQ,GAAG,CAAC;IAChB,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,EAAEO,CAAC,EAAE,EAAE;MACxB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,EAAEO,CAAC,EAAE,EAAE;QACxB,MAAM,CAACmB,CAAC,EAAEC,CAAC,CAAC,GAAGJ,IAAI,CAACd,MAAM,CAACH,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC;QACjC,MAAMqB,SAAS,GAAGf,IAAI,CAACgB,GAAG,CAACH,CAAC,GAAGpB,CAAC,CAAC,GAAGO,IAAI,CAACgB,GAAG,CAACF,CAAC,GAAGpB,CAAC,CAAC;QACnDkB,QAAQ,IAAIG,SAAS;MACzB;IACJ;IACA,OAAOH,QAAQ;EACnB;EACA,OAAOD,UAAU;AACrB;AAEA,SAASM,UAAUA,CAACrB,MAAM,EAAE;EACxB,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,MAAM,CAACL,MAAM,EAAEE,CAAC,EAAE,EAAE;IACpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,CAAC,CAAC,CAAC,CAACL,MAAM,EAAEG,CAAC,EAAE,EAAE;MACvC,IAAIE,MAAM,CAACH,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,CAAC,EAAE;QACpB,OAAO,CAACD,CAAC,EAAEC,CAAC,CAAC;MACjB;IACJ;EACJ;AACJ;AAEA,SAASwB,SAASA,CAACC,MAAM,EAAE;EACvB,MAAMvB,MAAM,GAAGuB,MAAM,CAACpB,GAAG,CAACqB,GAAG,IAAIA,GAAG,CAACZ,KAAK,CAAC,CAAC,CAAC;EAC7C,MAAM,CAACf,CAAC,EAAEC,CAAC,CAAC,GAAGuB,UAAU,CAACrB,MAAM,CAAC;EACjC,MAAMyB,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EAC/C,MAAMC,cAAc,GAAG,EAAE;EACzB,KAAK,MAAM,CAACC,EAAE,EAAEC,EAAE,CAAC,IAAIH,IAAI,EAAE;IACzB,MAAMR,CAAC,GAAGpB,CAAC,GAAG8B,EAAE;IAChB,MAAMT,CAAC,GAAGpB,CAAC,GAAG8B,EAAE;IAChB,IAAIX,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAGjB,MAAM,CAACL,MAAM,IAAIuB,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAGlB,MAAM,CAAC,CAAC,CAAC,CAACL,MAAM,EAAE;MAC/D,CAACK,MAAM,CAACH,CAAC,CAAC,CAACC,CAAC,CAAC,EAAEE,MAAM,CAACiB,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC,GAAG,CAAClB,MAAM,CAACiB,CAAC,CAAC,CAACC,CAAC,CAAC,EAAElB,MAAM,CAACH,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC;MAC3D4B,cAAc,CAACG,IAAI,CAAC7B,MAAM,CAACG,GAAG,CAACqB,GAAG,IAAIA,GAAG,CAACZ,KAAK,CAAC,CAAC,CAAC,CAAC;MACnD,CAACZ,MAAM,CAACH,CAAC,CAAC,CAACC,CAAC,CAAC,EAAEE,MAAM,CAACiB,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC,GAAG,CAAClB,MAAM,CAACiB,CAAC,CAAC,CAACC,CAAC,CAAC,EAAElB,MAAM,CAACH,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC;IAC/D;EACJ;EACA,OAAO4B,cAAc;AACzB;AAEA,SAASI,WAAWA,CAACC,OAAO,EAAEvC,IAAI,EAAE;EAChC,MAAMwC,IAAI,GAAG,CAACxC,IAAI,CAAC;EACnB,OAAOuC,OAAO,CAACvC,IAAI,CAAC,EAAE;IAClB,MAAMyC,GAAG,GAAGF,OAAO,CAACvC,IAAI,CAAC;IACzBwC,IAAI,CAACH,IAAI,CAACI,GAAG,CAAC;IACdzC,IAAI,GAAGyC,GAAG;EACd;EACA,OAAOD,IAAI,CAACE,OAAO,CAAC,CAAC;AACzB;AAEA,OAAO,SAASC,KAAKA,CAACnC,MAAM,EAAER,IAAI,EAAE;EAChC,MAAMuB,UAAU,GAAGF,SAAS,CAACrB,IAAI,CAAC;EAClC,MAAM4C,KAAK,GAAGC,IAAI,CAACC,SAAS,CAACtC,MAAM,CAAC;EACpC,MAAMuC,MAAM,GAAGF,IAAI,CAACC,SAAS,CAAC9C,IAAI,CAAC;EACnC,MAAMgD,IAAI,GAAG,CAAC,CAACzB,UAAU,CAACqB,KAAK,CAAC,EAAE,CAAC,EAAEK,UAAU,CAAC,CAAC;EACjD,MAAMV,OAAO,GAAG,CAAC,CAAC;EAClBA,OAAO,CAACM,IAAI,CAACC,SAAS,CAACF,KAAK,CAAC,CAAC,GAAG,IAAI;EAErC,OAAOI,IAAI,CAAC7C,MAAM,GAAG,CAAC,EAAE;IACpB,MAAM,CAAC+C,QAAQ,EAAEC,KAAK,EAAEpB,MAAM,CAAC,GAAGiB,IAAI,CAACI,KAAK,CAAC,CAAC;IAC9C,IAAIP,IAAI,CAACC,SAAS,CAACf,MAAM,CAAC,KAAKc,IAAI,CAACC,SAAS,CAACC,MAAM,CAAC,EAAE;MACnD;IACJ;IACA,KAAK,MAAMM,GAAG,IAAIvB,SAAS,CAACC,MAAM,CAAC,EAAE;MACjC,MAAMuB,MAAM,GAAGT,IAAI,CAACC,SAAS,CAACO,GAAG,CAAC;MAClC,IAAI,CAACd,OAAO,CAACe,MAAM,CAAC,EAAE;QAClBf,OAAO,CAACe,MAAM,CAAC,GAAGvB,MAAM;QACxBiB,IAAI,CAACX,IAAI,CAAC,CAACc,KAAK,GAAG,CAAC,GAAG5B,UAAU,CAAC8B,GAAG,CAAC,EAAEF,KAAK,GAAG,CAAC,EAAEE,GAAG,CAAC,CAAC;MAC5D;IACJ;IACAL,IAAI,CAACO,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,CAAC;EACpC;EAEA,IAAI,CAAClB,OAAO,CAACM,IAAI,CAACC,SAAS,CAACC,MAAM,CAAC,CAAC,EAAE;IAClCW,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;IAC7B,OAAO,IAAI;EACf;EAEA,MAAMnB,IAAI,GAAGF,WAAW,CAACC,OAAO,EAAEM,IAAI,CAACC,SAAS,CAACC,MAAM,CAAC,CAAC;EACzD,OAAOP,IAAI,CAAC7B,GAAG,CAACiD,IAAI,IAAIA,IAAI,CAACjD,GAAG,CAACqB,GAAG,IAAIA,GAAG,CAACZ,KAAK,CAAC,CAAC,CAAC,CAAC;AACzD"},"metadata":{},"sourceType":"module","externalDependencies":[]}